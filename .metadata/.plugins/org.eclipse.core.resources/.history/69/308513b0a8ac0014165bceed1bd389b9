import java.util.*;


public class Searches {
	private Deque<Integer> deque; 
	private AdjacencyMatrix matrix;
	private Set<Integer> set;
	
	public Searches(AdjacencyMatrix pMatrix){
		deque = new ArrayDeque<Integer>();	
		matrix = pMatrix; 
		set = new HashSet<Integer>();
	}
	
	/**
	 * This method runs the BFS algorithm and returns back the 
	 * shortest distance between the starting "root" and a target
	 * node. 
	 * @param The starting "root" of the algorithm
	 * @param The target node to be checked. 
	 * @return The number of nodes that the algorithm processed. 
	 */
	public int runBFS(int root, int target){
		deque.add(root);
		set.add(root);
		int count = 0;
		while (!deque.isEmpty()){
			int current = deque.pop();
			count++;
			if (current == target){
				return count;
			}
			ArrayList<Integer> adjacentEdges = findAdjacentEdges(current);
			for (int e = 0; e < adjacentEdges.size(); e++){
				int adjacentVertex = adjacentEdges.get(e);
				if (!set.contains((int) adjacentVertex)){
					deque.add(adjacentVertex);
					set.add(adjacentVertex);
				}
			}
			
		}
		System.out.println("All nodes have been examined");
		set.clear();
		deque.clear();
		return count;
	}
	
	 
	
	/**
	 * Overloaded method foor runBFS(). Instead of taking in a target node, 
	 * this method checks every single node.
	 * @param The starting "root" of the algorithm
	 * @param The target node to be checked. 
	 * @return The number of nodes that the algorithm processed. 
	 */
	public int runBFS(int root){
		deque.add(root);
		set.add(root);
		int count = 0;
		while (!deque.isEmpty()){
			int current = deque.pop();
			count++;	
			ArrayList<Integer> adjacentEdges = findAdjacentEdges(current);
			for (int e = 0; e < adjacentEdges.size(); e++){
				int adjacentVertex = adjacentEdges.get(e);
				if (!set.contains((int) adjacentVertex)){
					deque.add(adjacentVertex);
					set.add(adjacentVertex);
				}
			}
			
		}
		System.out.println("All nodes have been examined");
		set.clear();
		deque.clear();
		return count;
	}
	
	public ArrayList<Integer> findAdjacentEdges(int node){
		ArrayList<Integer> arr = new ArrayList<Integer>();
		for (int i = 0; i < matrix.getLength(); i++){
			if (matrix.hasEdge(node,i)) arr.add(i);
		}
		return arr;
	}
	
	public void runDFS(int root){
		set.add(root);
		ArrayList<Integer> adjacentEdges = findAdjacentEdges(root);
		for (int e = 0; e < adjacentEdges.size(); e++){
			int adjacentVertex = adjacentEdges.get(e);
			if (!set.contains((int) adjacentVertex)){
				runDFS(adjacentVertex);
			}
		}
	}
	
	
}
