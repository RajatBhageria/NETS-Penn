import java.util.*;


public class Searches {
	private Deque<Integer> deque; 
	private AdjacencyMatrix matrix;
	private Set<Integer> set;
	
	public Searches(AdjacencyMatrix pMatrix){
		deque = new ArrayDeque<Integer>();	
		matrix = pMatrix; 
		set = new HashSet<Integer>();
	}
	
	/**
	 * This method runs the BFS algorithm and returns back the 
	 * shortest distance between the starting "root" and a target
	 * node. 
	 * @param The starting "root" of the algorithm
	 * @param The target node to be checked. 
	 * @return The number of nodes that the algorithm processed. 
	 */
	public int runBFS(int root, int target){
		if (root == target) return 0; 
		deque.add(root);
		set.add(root);
		int count = 0;
		while (!deque.isEmpty()){
			int current = deque.pop();
			ArrayList<Integer> adjacentEdges = findAdjacentEdges(current);
			System.out.println(adjacentEdges);

			if (adjacentEdges.size()>0) count++;

			for (int e = 0; e < adjacentEdges.size(); e++){
				int adjacentVertex = adjacentEdges.get(e);
				if (!set.contains((int) adjacentVertex)){

					if (adjacentVertex == target){
						return count;
					}

					deque.add(adjacentVertex);
					set.add(adjacentVertex);
				}
			}
			
		}
		System.out.println("All nodes have been examined");
		System.out.println(set);
		set.clear();
		deque.clear();
		return INTEGER_MAX; 
	}
	
	
	public  int breadthFirstSearch(int startNode, int targetNode) {
		int counter = 0;
		Integer currentNode;
		Deque<Integer> deque = new ArrayDeque<Integer>();
		Set<Integer> iterated = new HashSet<Integer>();
		deque.add(startNode);
		iterated.add(startNode);
		while (!deque.isEmpty()) {
			currentNode = deque.pop();
			ArrayList<Integer> adjEdges = findAdjacentEdges(currentNode);
			if (adjEdges.size() > 0) {
				counter++;
			}
			for (int i = 0; i < adjEdges.size(); i++) {
				int temp = adjEdges.get(i);
				if (!iterated.contains(temp)) {
					if(temp == targetNode) {
						return counter;
					}
					iterated.add(temp);
					deque.add(temp);
				}
				
			}
			
		}
		System.out.println("Iterated: " + iterated);
		return counter;
	}
	 
	
	/**
	 * Overloaded method foor runBFS(). Instead of taking in a target node, 
	 * this method checks every single node.
	 * @param The starting "root" of the algorithm
	 * @param The target node to be checked. 
	 * @return The number of nodes that the algorithm processed. 
	 */
	public int runBFS(int root){
		deque.add(root);
		set.add(root);
		int count = 0;
		while (!deque.isEmpty()){
			int current = deque.pop();
			count++;	
			ArrayList<Integer> adjacentEdges = findAdjacentEdges(current);
			for (int e = 0; e < adjacentEdges.size(); e++){
				int adjacentVertex = adjacentEdges.get(e);
				if (!set.contains((int) adjacentVertex)){
					deque.add(adjacentVertex);
					set.add(adjacentVertex);
				}
			}
			
		}
		System.out.println("All nodes have been examined");
		set.clear();
		deque.clear();
		return count;
	}
	
	/**
	 * Given a starting node, findAdjacentEdges returns an ArrayList with 
	 * all the nodes that are adjacent to the node that was passed in 
	 * as a parameter. 
	 * @param The starting "root" of the algorithm
	 * @return An ArrayList of all adjacent edges. 
	 */
	public ArrayList<Integer> findAdjacentEdges(int node){
		ArrayList<Integer> arr = new ArrayList<Integer>();
		for (int i = 0; i < matrix.getLength(); i++){
			if (matrix.hasEdge(node,i)) arr.add(i);
		}
		return arr;
	}
	
	/**
	 * This method runs the DFS algorithm. p
	 * @param The starting "root" of the algorithm
	 */
	public void runDFS(int root){
		set.add(root);
		ArrayList<Integer> adjacentEdges = findAdjacentEdges(root);
		for (int e = 0; e < adjacentEdges.size(); e++){
			int adjacentVertex = adjacentEdges.get(e);
			if (!set.contains((int) adjacentVertex)){
				runDFS(adjacentVertex);
			}
		}
	}
	
	
}
